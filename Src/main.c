/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "STM32F103C6.h"
#include "GPIO.h"
#include "keypad.h"
#include "lcd.h"
#include "USART.h"
#include "SPI.h"
#include "I2C.h"
#include "TIMER.h"
#include "app.h"


#define 	N_ID		3


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


char Enter_Data;
char Exit_Data;

Driver_t  Garage_List[N_ID];
volatile char ValidIDs[N_ID];

void GetValidIDs ();
void Control_Gate(TIMER_t *SERVO,GPIO_PinConfig_t * SENSOR, uint32_t State,uint32_t CH );
Std_ReturnType Check_In_ID ();
Std_ReturnType Check_Out_ID();
Std_ReturnType valid =E_NOT_OK;
void ENTER_CALLBACK ();
void EXIT_CALLBACK ();


keypad_t keypad = {
		.keypad_row_pins[0].GPIO_Port=GPIOB ,
		.keypad_row_pins[0].GPIO_PinNumber = 0 ,
		.keypad_row_pins[0].GPIO_Output_Speed=GPIO_SPEED_2M,
		.keypad_row_pins[0].GPIO_MODE = GPIO_FLOATING_INPUT_MODE,

		.keypad_row_pins[1].GPIO_Port=GPIOB ,
		.keypad_row_pins[1].GPIO_PinNumber = 1 ,
		.keypad_row_pins[1].GPIO_Output_Speed=GPIO_SPEED_2M,
		.keypad_row_pins[1].GPIO_MODE = GPIO_FLOATING_INPUT_MODE,

		.keypad_row_pins[2].GPIO_Port=GPIOB ,
		.keypad_row_pins[2].GPIO_PinNumber = 3 ,
		.keypad_row_pins[2].GPIO_Output_Speed=GPIO_SPEED_2M,
		.keypad_row_pins[2].GPIO_MODE = GPIO_FLOATING_INPUT_MODE,

		.keypad_row_pins[3].GPIO_Port=GPIOB ,
		.keypad_row_pins[3].GPIO_PinNumber = 4 ,
		.keypad_row_pins[3].GPIO_Output_Speed=GPIO_SPEED_2M,
		.keypad_row_pins[3].GPIO_MODE = GPIO_FLOATING_INPUT_MODE,

		.keypad_columns_pins[0].GPIO_Port = GPIOB,
		.keypad_columns_pins[0].GPIO_PinNumber = 5,
		.keypad_columns_pins[0].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,
		.keypad_columns_pins[0].GPIO_Output_Speed=GPIO_SPEED_2M,

		.keypad_columns_pins[1].GPIO_Port = GPIOB,
		.keypad_columns_pins[1].GPIO_PinNumber = 10,
		.keypad_columns_pins[1].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,
		.keypad_columns_pins[1].GPIO_Output_Speed=GPIO_SPEED_2M,

		.keypad_columns_pins[2].GPIO_Port = GPIOB,
		.keypad_columns_pins[2].GPIO_PinNumber = 11,
		.keypad_columns_pins[2].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,
		.keypad_columns_pins[2].GPIO_Output_Speed=GPIO_SPEED_2M,

		.keypad_columns_pins[3].GPIO_Port = GPIOA,
		.keypad_columns_pins[3].GPIO_PinNumber = 8	,
		.keypad_columns_pins[3].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,
		.keypad_columns_pins[3].GPIO_Output_Speed=GPIO_SPEED_2M


};

chr_lcd_4bit_t ADMIN = {
		.lcd_en.GPIO_Port=GPIOA,
		.lcd_en.GPIO_PinNumber = 4 ,
		.lcd_en.GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_en.GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_rs.GPIO_Port=GPIOB,
		.lcd_rs.GPIO_PinNumber = 2 ,
		.lcd_rs.GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_rs.GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[0].GPIO_Port=GPIOB,
		.lcd_data[0].GPIO_PinNumber = 6,
		.lcd_data[0].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[0].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[1].GPIO_Port=GPIOB,
		.lcd_data[1].GPIO_PinNumber = 7,
		.lcd_data[1].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[1].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[2].GPIO_Port=GPIOB,
		.lcd_data[2].GPIO_PinNumber = 8,
		.lcd_data[2].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[2].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[3].GPIO_Port=GPIOB,
		.lcd_data[3].GPIO_PinNumber = 9,
		.lcd_data[3].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[3].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE

};

chr_lcd_4bit_t DRIVER = {
		.lcd_en.GPIO_Port=GPIOA,
		.lcd_en.GPIO_PinNumber = 6 ,
		.lcd_en.GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_en.GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_rs.GPIO_Port=GPIOA,
		.lcd_rs.GPIO_PinNumber = 5 ,
		.lcd_rs.GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_rs.GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[0].GPIO_Port=GPIOA,
		.lcd_data[0].GPIO_PinNumber = 12,
		.lcd_data[0].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[0].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[1].GPIO_Port=GPIOA,
		.lcd_data[1].GPIO_PinNumber = 13,
		.lcd_data[1].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[1].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[2].GPIO_Port=GPIOA,
		.lcd_data[2].GPIO_PinNumber = 14,
		.lcd_data[2].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[2].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE,

		.lcd_data[3].GPIO_Port=GPIOA,
		.lcd_data[3].GPIO_PinNumber = 15,
		.lcd_data[3].GPIO_Output_Speed=GPIO_SPEED_2M,
		.lcd_data[3].GPIO_MODE =GPIO_OUTPUT_PUSHPULL_MODE

};

UART_Config Enter={
		.BaudRate =9600,
		.HwFlowCtl=UART_HwFlowCtl_NONE,
		.PEIE_IRQ_Enable=0,
		.P_IRQ_CallBack= ENTER_CALLBACK,
		.Parity=UART_Parity__NONE,
		.Payload_Length= UART_Payload_Length_8B,
		.RXNEIE_IRQ_Enable=1,
		.StopBits=UART_StopBits__1,
		.TCIE_IRQ_Enable=0,
		.TXEIE_IRQ_Enable=0,
		.USART_Mode =UART_MODE_TX_RX,
		.USARTx= USART1
};

UART_Config Exit={
		.BaudRate =9600,
		.HwFlowCtl=UART_HwFlowCtl_NONE,
		.PEIE_IRQ_Enable=0,
		.P_IRQ_CallBack= EXIT_CALLBACK,
		.Parity=UART_Parity__NONE,
		.Payload_Length= UART_Payload_Length_8B,
		.RXNEIE_IRQ_Enable=1,
		.StopBits=UART_StopBits__1,
		.TCIE_IRQ_Enable=0,
		.TXEIE_IRQ_Enable=0,
		.USART_Mode =UART_MODE_TX_RX,
		.USARTx= USART2
};

GPIO_PinConfig_t RIP1={
		.GPIO_Port=GPIOA,
		.GPIO_MODE= GPIO_FLOATING_INPUT_MODE,
		.GPIO_PinNumber=11,
		.GPIO_Output_Speed=GPIO_SPEED_10M
};

GPIO_PinConfig_t RIP2={
		.GPIO_Port=GPIOA,
		.GPIO_MODE= GPIO_FLOATING_INPUT_MODE,
		.GPIO_PinNumber=1,
		.GPIO_Output_Speed=GPIO_SPEED_10M
};

TIMER_t PWM2={
		.TIMERx= TIM2,
		.CLOCK=8000000,
		.FREQUENCY=600
};
TIMER_t PWM3={
		.TIMERx= TIM3,
		.CLOCK=8000000,
		.FREQUENCY=600
};

void ENTER_CALLBACK (){
	Enter_Data=USART1->DR;
	MCAL_UART_SendData(&Enter, &Enter_Data, 1);


}
void EXIT_CALLBACK (){

	Exit_Data=USART2->DR;
	MCAL_UART_SendData(&Exit, &Exit_Data, 1);

}
int main(void)
{

	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

	PWM(&PWM2, 1, 1);
	PWM(&PWM3, 2, 1);
	keypad_initialize(&keypad);
	lcd_4bit_intialize(&ADMIN);
	lcd_4bit_intialize(&DRIVER);
	MCAL_UART_Init(&Enter);
	MCAL_UART_GPIO_Set_Pins (&Enter);
	MCAL_UART_Init(&Exit);
	MCAL_UART_GPIO_Set_Pins (&Exit);


	GetValidIDs();
	while (1){

		lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
		lcd_4bit_send_string(&DRIVER,"Enter Your ID :  ");

		while(Enter_Data ==0&& Exit_Data ==0);
		if(Check_In_ID())
			Control_Gate(&PWM2, &RIP1, 1,1);

		if(Check_Out_ID())
			Control_Gate(&PWM3, &RIP2, 1,2);
	}
}



void GetValidIDs (){

	lcd_4bit_send_string(&ADMIN, "Valid IDs Are :  ");
	for ( int i = 0;  i < N_ID; ++ i) {
		ValidIDs[i]=keypad_get_value_blocking(&keypad);




		Garage_List[i].ID =ValidIDs[i];
		Garage_List[i].state =OUT_GARAGE;
		lcd_4bit_send_char_data(&ADMIN, ValidIDs[i]);
		lcd_4bit_send_char_data(&ADMIN, ' ');
	}

}

Std_ReturnType Check_In_ID (){
	if(Enter_Data != 0){
		for ( int i = 0;  i < N_ID; i++) {
			if (Enter_Data == ValidIDs[i]) {
				if (Garage_List[i].state== IN_GARAGE) {
					lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
					lcd_4bit_send_string(&DRIVER, "Already In");
					Enter_Data=0;
					delay_ms(500);
					return E_NOT_OK;
				}
				else{
					Garage_List[i].state =IN_GARAGE;
					lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
					lcd_4bit_send_string(&DRIVER, "WELCOME");
					Enter_Data=0;
					return E_OK;
				}
			}
		}
		if (Enter_Data ==0 ||Enter_Data =='/0'||Enter_Data =='0') {}
		else{
			lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
			lcd_4bit_send_string(&DRIVER, "Wrong ,Try Again");
			Enter_Data=0;
			delay_ms(500);
			return E_NOT_OK;

		}
	}
}

Std_ReturnType Check_Out_ID(){
	if(Exit_Data != 0){
		for ( int i = 0;  i < N_ID; i++) {
			if (Exit_Data == ValidIDs[i]) {
				if (Garage_List[i].state== OUT_GARAGE) {
					lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
					lcd_4bit_send_string(&DRIVER, "Already Out");
					Exit_Data=0;
					delay_ms(500);
					return E_NOT_OK;
				}
				else{
					Garage_List[i].state =OUT_GARAGE;
					lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
					lcd_4bit_send_string(&DRIVER, "BYE");
					Exit_Data=0;
					return E_OK;
				}
			}
		}
		if (Exit_Data ==0 ||Exit_Data =='/0'||Exit_Data =='0') {}
		else{
			lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
			lcd_4bit_send_string(&DRIVER, "Wrong ,Try Again");
			Exit_Data=0;
			delay_ms(500);
			return E_NOT_OK;

		}}
}

void Control_Gate(TIMER_t *SERVO,GPIO_PinConfig_t * SENSOR, uint32_t State,uint32_t CH ){
	if(State){
		while(!gpio_pin_read_logic(SENSOR));
		lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
		lcd_4bit_send_string(&DRIVER, "Open Gate");
		PWM(SERVO, CH, 75); //45 degree
		while(gpio_pin_read_logic(SENSOR));
		lcd_4bit_send_command(&DRIVER, _LCD_CLEAR);
		lcd_4bit_send_string(&DRIVER, "Close Gate");
		PWM(SERVO, CH, 1); //45 degree

	}

}





















